import 'dart:typed_data';

import 'package:convert/convert.dart';

/// The type of Boltz swap.
enum SwapType {
  /// Reverse submarine: Lightning → EVM (swap-in).
  swapIn,

  /// Submarine: EVM → Lightning (swap-out).
  swapOut,
}

/// The persisted status of a swap for recovery purposes.
///
/// These map to meaningful checkpoints — not every Boltz WS status.
/// A swap can only move forward through these states (or to failed/refunded).
enum SwapRecordStatus {
  /// Swap request created with Boltz but no funds committed yet.
  created,

  /// Lightning invoice has been paid (swap-in) or funds locked on-chain (swap-out).
  /// At this point, funds are at risk and recovery data is critical.
  funded,

  /// Claim transaction has been broadcast (swap-in) or invoice paid out (swap-out).
  /// Waiting for confirmation.
  claiming,

  /// Swap completed successfully. Kept for audit/history.
  completed,

  /// Swap failed and needs refund (swap-out) or claim retry (swap-in).
  needsAction,

  /// Refund transaction broadcast (swap-out only). Waiting for confirmation.
  refunding,

  /// Refund confirmed (swap-out) or swap otherwise resolved.
  refunded,

  /// Terminal failure — either funds recovered or irrecoverable.
  failed,
}

/// A serializable record of all data needed to resume or refund a swap.
///
/// This is the single most important data structure for swap safety.
/// It MUST be persisted to disk at every critical state transition.
class SwapRecord {
  /// Unique identifier for this swap record (UUID or Boltz swap ID).
  final String id;

  /// The Boltz swap ID returned from the API.
  final String boltzId;

  /// Whether this is a swap-in (reverse submarine) or swap-out (submarine).
  final SwapType type;

  /// Current persisted status.
  SwapRecordStatus status;

  /// When this record was created.
  final DateTime createdAt;

  /// When this record was last updated.
  DateTime updatedAt;

  // ── Swap-In (Reverse Submarine) specific fields ──

  /// The preimage generated by us. CRITICAL for claiming.
  /// Without this, locked on-chain funds from a reverse swap are LOST.
  final String? preimageHex;

  /// SHA-256 hash of the preimage.
  final String? preimageHash;

  /// The on-chain amount Boltz will lock (in satoshis).
  final int? onchainAmountSat;

  /// The refund address from the lockup transaction (needed for claim call).
  final String? refundAddress;

  // ── Swap-Out (Submarine) specific fields ──

  /// The Lightning invoice we generated for receiving payment.
  final String? invoice;

  /// The preimage hash extracted from our invoice (needed for refund).
  final String? invoicePreimageHashHex;

  /// Boltz's claim address (needed for refund call).
  final String? claimAddress;

  /// The expected amount we locked in the contract (in wei as hex string).
  final String? lockedAmountWeiHex;

  /// Our EVM address that locked the funds (needed for EVM contract log recovery).
  final String? lockerAddress;

  /// Transaction hash of our lock transaction.
  final String? lockTxHash;

  // ── Shared fields ──

  /// The timeout block height for the HTLC.
  final int? timeoutBlockHeight;

  /// The EVM chain ID (for multi-chain support).
  final int? chainId;

  /// Transaction hash of claim or refund transaction, once broadcast.
  String? resolutionTxHash;

  /// Last known Boltz WebSocket status string.
  String? lastBoltzStatus;

  /// Human-readable error message if the swap failed.
  String? errorMessage;

  SwapRecord({
    required this.id,
    required this.boltzId,
    required this.type,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
    this.preimageHex,
    this.preimageHash,
    this.onchainAmountSat,
    this.refundAddress,
    this.invoice,
    this.invoicePreimageHashHex,
    this.claimAddress,
    this.lockedAmountWeiHex,
    this.lockerAddress,
    this.lockTxHash,
    this.timeoutBlockHeight,
    this.chainId,
    this.resolutionTxHash,
    this.lastBoltzStatus,
    this.errorMessage,
  });

  /// Create a record for a new swap-in (reverse submarine).
  factory SwapRecord.forSwapIn({
    required String boltzId,
    required List<int> preimage,
    required String preimageHash,
    required int onchainAmountSat,
    required int timeoutBlockHeight,
    required int chainId,
  }) {
    final now = DateTime.now();
    return SwapRecord(
      id: boltzId,
      boltzId: boltzId,
      type: SwapType.swapIn,
      status: SwapRecordStatus.created,
      createdAt: now,
      updatedAt: now,
      preimageHex: hex.encode(preimage),
      preimageHash: preimageHash,
      onchainAmountSat: onchainAmountSat,
      timeoutBlockHeight: timeoutBlockHeight,
      chainId: chainId,
    );
  }

  /// Create a record for a new swap-out (submarine).
  factory SwapRecord.forSwapOut({
    required String boltzId,
    required String invoice,
    required String invoicePreimageHashHex,
    required String claimAddress,
    required BigInt lockedAmountWei,
    required String lockerAddress,
    required int timeoutBlockHeight,
    required int chainId,
  }) {
    final now = DateTime.now();
    return SwapRecord(
      id: boltzId,
      boltzId: boltzId,
      type: SwapType.swapOut,
      status: SwapRecordStatus.created,
      createdAt: now,
      updatedAt: now,
      invoice: invoice,
      invoicePreimageHashHex: invoicePreimageHashHex,
      claimAddress: claimAddress,
      lockedAmountWeiHex: lockedAmountWei.toRadixString(16),
      lockerAddress: lockerAddress,
      timeoutBlockHeight: timeoutBlockHeight,
      chainId: chainId,
    );
  }

  /// Recover the preimage bytes from the stored hex.
  Uint8List? get preimageBytes =>
      preimageHex != null ? Uint8List.fromList(hex.decode(preimageHex!)) : null;

  /// Recover the invoice preimage hash bytes from stored hex.
  Uint8List? get invoicePreimageHashBytes => invoicePreimageHashHex != null
      ? Uint8List.fromList(hex.decode(invoicePreimageHashHex!))
      : null;

  /// Recover the locked amount as BigInt from hex.
  BigInt? get lockedAmountWei => lockedAmountWeiHex != null
      ? BigInt.parse(lockedAmountWeiHex!, radix: 16)
      : null;

  /// Whether this swap is in a terminal state (no further action possible).
  bool get isTerminal =>
      status == SwapRecordStatus.completed ||
      status == SwapRecordStatus.refunded ||
      status == SwapRecordStatus.failed;

  /// Whether this swap has funds at risk that may need recovery.
  bool get needsRecovery =>
      !isTerminal &&
      (status == SwapRecordStatus.funded ||
          status == SwapRecordStatus.claiming ||
          status == SwapRecordStatus.needsAction);

  /// Whether the timelock has expired based on a given current block height.
  bool isTimelockExpired(int currentBlockHeight) =>
      timeoutBlockHeight != null && currentBlockHeight >= timeoutBlockHeight!;

  SwapRecord copyWithStatus(
    SwapRecordStatus newStatus, {
    String? resolutionTxHash,
    String? lastBoltzStatus,
    String? errorMessage,
    String? refundAddress,
    String? lockTxHash,
  }) {
    return SwapRecord(
      id: id,
      boltzId: boltzId,
      type: type,
      status: newStatus,
      createdAt: createdAt,
      updatedAt: DateTime.now(),
      preimageHex: preimageHex,
      preimageHash: preimageHash,
      onchainAmountSat: onchainAmountSat,
      refundAddress: refundAddress ?? this.refundAddress,
      invoice: invoice,
      invoicePreimageHashHex: invoicePreimageHashHex,
      claimAddress: claimAddress,
      lockedAmountWeiHex: lockedAmountWeiHex,
      lockerAddress: lockerAddress,
      lockTxHash: lockTxHash ?? this.lockTxHash,
      timeoutBlockHeight: timeoutBlockHeight,
      chainId: chainId,
      resolutionTxHash: resolutionTxHash ?? this.resolutionTxHash,
      lastBoltzStatus: lastBoltzStatus ?? this.lastBoltzStatus,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'boltzId': boltzId,
    'type': type.name,
    'status': status.name,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
    if (preimageHex != null) 'preimageHex': preimageHex,
    if (preimageHash != null) 'preimageHash': preimageHash,
    if (onchainAmountSat != null) 'onchainAmountSat': onchainAmountSat,
    if (refundAddress != null) 'refundAddress': refundAddress,
    if (invoice != null) 'invoice': invoice,
    if (invoicePreimageHashHex != null)
      'invoicePreimageHashHex': invoicePreimageHashHex,
    if (claimAddress != null) 'claimAddress': claimAddress,
    if (lockedAmountWeiHex != null) 'lockedAmountWeiHex': lockedAmountWeiHex,
    if (lockerAddress != null) 'lockerAddress': lockerAddress,
    if (lockTxHash != null) 'lockTxHash': lockTxHash,
    if (timeoutBlockHeight != null) 'timeoutBlockHeight': timeoutBlockHeight,
    if (chainId != null) 'chainId': chainId,
    if (resolutionTxHash != null) 'resolutionTxHash': resolutionTxHash,
    if (lastBoltzStatus != null) 'lastBoltzStatus': lastBoltzStatus,
    if (errorMessage != null) 'errorMessage': errorMessage,
  };

  factory SwapRecord.fromJson(Map<String, dynamic> json) => SwapRecord(
    id: json['id'] as String,
    boltzId: json['boltzId'] as String,
    type: SwapType.values.byName(json['type'] as String),
    status: SwapRecordStatus.values.byName(json['status'] as String),
    createdAt: DateTime.parse(json['createdAt'] as String),
    updatedAt: DateTime.parse(json['updatedAt'] as String),
    preimageHex: json['preimageHex'] as String?,
    preimageHash: json['preimageHash'] as String?,
    onchainAmountSat: json['onchainAmountSat'] as int?,
    refundAddress: json['refundAddress'] as String?,
    invoice: json['invoice'] as String?,
    invoicePreimageHashHex: json['invoicePreimageHashHex'] as String?,
    claimAddress: json['claimAddress'] as String?,
    lockedAmountWeiHex: json['lockedAmountWeiHex'] as String?,
    lockerAddress: json['lockerAddress'] as String?,
    lockTxHash: json['lockTxHash'] as String?,
    timeoutBlockHeight: json['timeoutBlockHeight'] as int?,
    chainId: json['chainId'] as int?,
    resolutionTxHash: json['resolutionTxHash'] as String?,
    lastBoltzStatus: json['lastBoltzStatus'] as String?,
    errorMessage: json['errorMessage'] as String?,
  );

  @override
  String toString() =>
      'SwapRecord($type, $boltzId, $status, updated: $updatedAt)';
}
