import 'dart:typed_data';

import 'package:convert/convert.dart';

/// The persisted status of a swap for recovery purposes.
///
/// These map to meaningful checkpoints — not every Boltz WS status.
/// A swap can only move forward through these states (or to failed/refunded).
enum SwapRecordStatus {
  /// Swap request created with Boltz but no funds committed yet.
  created,

  /// Lightning invoice has been paid (swap-in) or funds locked on-chain (swap-out).
  /// At this point, funds are at risk and recovery data is critical.
  funded,

  /// Claim transaction has been broadcast (swap-in) or invoice paid out (swap-out).
  /// Waiting for confirmation.
  claiming,

  /// Swap completed successfully. Kept for audit/history.
  completed,

  /// Swap failed and needs refund (swap-out) or claim retry (swap-in).
  needsAction,

  /// Refund transaction broadcast (swap-out only). Waiting for confirmation.
  refunding,

  /// Refund confirmed (swap-out) or swap otherwise resolved.
  refunded,

  /// Terminal failure — either funds recovered or irrecoverable.
  failed,
}

/// A serializable record of all data needed to resume or refund a swap.
///
/// This is a sealed hierarchy: [SwapInRecord] for reverse submarine swaps
/// (Lightning → EVM) and [SwapOutRecord] for submarine swaps (EVM → Lightning).
/// Each subclass carries only the fields relevant to its direction, making
/// type-specific fields non-nullable and enabling exhaustive switch matching.
sealed class SwapRecord {
  /// Unique identifier for this swap record (UUID or Boltz swap ID).
  final String id;

  /// The Boltz swap ID returned from the API.
  final String boltzId;

  /// Current persisted status.
  SwapRecordStatus status;

  /// When this record was created.
  final DateTime createdAt;

  /// When this record was last updated.
  DateTime updatedAt;

  /// The timeout block height for the HTLC.
  final int timeoutBlockHeight;

  /// The EVM chain ID (for multi-chain support).
  final int chainId;

  /// Transaction hash of claim or refund transaction, once broadcast.
  String? resolutionTxHash;

  /// Last known Boltz WebSocket status string.
  String? lastBoltzStatus;

  /// Human-readable error message if the swap failed.
  String? errorMessage;

  SwapRecord({
    required this.id,
    required this.boltzId,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
    required this.timeoutBlockHeight,
    required this.chainId,
    this.resolutionTxHash,
    this.lastBoltzStatus,
    this.errorMessage,
  });

  /// Whether this swap is in a terminal state (no further action possible).
  bool get isTerminal =>
      status == SwapRecordStatus.completed ||
      status == SwapRecordStatus.refunded ||
      status == SwapRecordStatus.failed;

  /// Whether this swap has funds at risk that may need recovery.
  bool get needsRecovery =>
      !isTerminal &&
      (status == SwapRecordStatus.funded ||
          status == SwapRecordStatus.claiming ||
          status == SwapRecordStatus.needsAction);

  /// Whether the timelock has expired based on a given current block height.
  bool isTimelockExpired(int currentBlockHeight) =>
      currentBlockHeight >= timeoutBlockHeight;

  /// Create a copy with a new status and optional metadata overrides.
  SwapRecord copyWithStatus(
    SwapRecordStatus newStatus, {
    String? resolutionTxHash,
    String? lastBoltzStatus,
    String? errorMessage,
  });

  /// Serialize to a JSON map.
  Map<String, dynamic> toJson();

  /// Deserialize from a JSON map, dispatching to the correct subclass.
  factory SwapRecord.fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String?;
    if (type == 'swapIn') {
      return SwapInRecord._fromJson(json);
    } else if (type == 'swapOut') {
      return SwapOutRecord._fromJson(json);
    }
    // Fallback: inspect fields to handle legacy data
    if (json.containsKey('preimageHex')) {
      return SwapInRecord._fromJson(json);
    }
    return SwapOutRecord._fromJson(json);
  }

  @override
  String toString();
}

// ─── Swap-In (Reverse Submarine: Lightning → EVM) ────────────────────────

/// A record for a swap-in (reverse submarine) swap.
///
/// All critical claim fields are non-nullable — if we have a swap-in record,
/// we have everything needed to attempt a claim (assuming [refundAddress] has
/// been learned from the lockup transaction).
class SwapInRecord extends SwapRecord {
  /// The preimage generated by us. CRITICAL for claiming.
  /// Without this, locked on-chain funds from a reverse swap are LOST.
  final String preimageHex;

  /// SHA-256 hash of the preimage.
  final String preimageHash;

  /// The on-chain amount Boltz will lock (in satoshis).
  final int onchainAmountSat;

  /// The refund address from the lockup transaction (needed for claim call).
  /// May be null until we observe Boltz's lockup transaction.
  String? refundAddress;

  SwapInRecord({
    required super.id,
    required super.boltzId,
    required super.status,
    required super.createdAt,
    required super.updatedAt,
    required super.timeoutBlockHeight,
    required super.chainId,
    required this.preimageHex,
    required this.preimageHash,
    required this.onchainAmountSat,
    this.refundAddress,
    super.resolutionTxHash,
    super.lastBoltzStatus,
    super.errorMessage,
  });

  /// Create a record for a new swap-in.
  factory SwapInRecord.create({
    required String boltzId,
    required List<int> preimage,
    required String preimageHash,
    required int onchainAmountSat,
    required int timeoutBlockHeight,
    required int chainId,
  }) {
    final now = DateTime.now();
    return SwapInRecord(
      id: boltzId,
      boltzId: boltzId,
      status: SwapRecordStatus.created,
      createdAt: now,
      updatedAt: now,
      preimageHex: hex.encode(preimage),
      preimageHash: preimageHash,
      onchainAmountSat: onchainAmountSat,
      timeoutBlockHeight: timeoutBlockHeight,
      chainId: chainId,
    );
  }

  /// Recover the preimage bytes from the stored hex.
  Uint8List get preimageBytes => Uint8List.fromList(hex.decode(preimageHex));

  /// Extract validated claim parameters, or null if [refundAddress] is
  /// not yet known (lockup transaction hasn't been observed).
  SwapInClaimParams? get claimParams {
    final refund = refundAddress;
    if (refund == null) return null;
    return SwapInClaimParams(
      preimage: preimageBytes,
      onchainAmountSat: onchainAmountSat,
      refundAddress: refund,
      timeoutBlockHeight: timeoutBlockHeight,
    );
  }

  @override
  SwapInRecord copyWithStatus(
    SwapRecordStatus newStatus, {
    String? resolutionTxHash,
    String? lastBoltzStatus,
    String? errorMessage,
    String? refundAddress,
  }) {
    return SwapInRecord(
      id: id,
      boltzId: boltzId,
      status: newStatus,
      createdAt: createdAt,
      updatedAt: DateTime.now(),
      preimageHex: preimageHex,
      preimageHash: preimageHash,
      onchainAmountSat: onchainAmountSat,
      refundAddress: refundAddress ?? this.refundAddress,
      timeoutBlockHeight: timeoutBlockHeight,
      chainId: chainId,
      resolutionTxHash: resolutionTxHash ?? this.resolutionTxHash,
      lastBoltzStatus: lastBoltzStatus ?? this.lastBoltzStatus,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'boltzId': boltzId,
        'type': 'swapIn',
        'status': status.name,
        'createdAt': createdAt.toIso8601String(),
        'updatedAt': updatedAt.toIso8601String(),
        'preimageHex': preimageHex,
        'preimageHash': preimageHash,
        'onchainAmountSat': onchainAmountSat,
        'timeoutBlockHeight': timeoutBlockHeight,
        'chainId': chainId,
        if (refundAddress != null) 'refundAddress': refundAddress,
        if (resolutionTxHash != null) 'resolutionTxHash': resolutionTxHash,
        if (lastBoltzStatus != null) 'lastBoltzStatus': lastBoltzStatus,
        if (errorMessage != null) 'errorMessage': errorMessage,
      };

  factory SwapInRecord._fromJson(Map<String, dynamic> json) => SwapInRecord(
        id: json['id'] as String,
        boltzId: json['boltzId'] as String,
        status: SwapRecordStatus.values.byName(json['status'] as String),
        createdAt: DateTime.parse(json['createdAt'] as String),
        updatedAt: DateTime.parse(json['updatedAt'] as String),
        preimageHex: json['preimageHex'] as String,
        preimageHash: json['preimageHash'] as String,
        onchainAmountSat: json['onchainAmountSat'] as int,
        timeoutBlockHeight: json['timeoutBlockHeight'] as int,
        chainId: json['chainId'] as int,
        refundAddress: json['refundAddress'] as String?,
        resolutionTxHash: json['resolutionTxHash'] as String?,
        lastBoltzStatus: json['lastBoltzStatus'] as String?,
        errorMessage: json['errorMessage'] as String?,
      );

  @override
  String toString() => 'SwapInRecord($boltzId, $status, updated: $updatedAt)';
}

// ─── Swap-Out (Submarine: EVM → Lightning) ───────────────────────────────

/// A record for a swap-out (submarine) swap.
///
/// All refund fields are non-nullable — if we have a swap-out record, we have
/// everything needed to attempt a cooperative or timelock refund.
class SwapOutRecord extends SwapRecord {
  /// The Lightning invoice we generated for receiving payment.
  final String invoice;

  /// The preimage hash extracted from our invoice (needed for refund).
  final String invoicePreimageHashHex;

  /// Boltz's claim address (needed for refund call).
  final String claimAddress;

  /// The expected amount we locked in the contract (in wei as hex string).
  final String lockedAmountWeiHex;

  /// Our EVM address that locked the funds (needed for EVM contract log recovery).
  final String lockerAddress;

  /// Transaction hash of our lock transaction.
  String? lockTxHash;

  SwapOutRecord({
    required super.id,
    required super.boltzId,
    required super.status,
    required super.createdAt,
    required super.updatedAt,
    required super.timeoutBlockHeight,
    required super.chainId,
    required this.invoice,
    required this.invoicePreimageHashHex,
    required this.claimAddress,
    required this.lockedAmountWeiHex,
    required this.lockerAddress,
    this.lockTxHash,
    super.resolutionTxHash,
    super.lastBoltzStatus,
    super.errorMessage,
  });

  /// Create a record for a new swap-out.
  factory SwapOutRecord.create({
    required String boltzId,
    required String invoice,
    required String invoicePreimageHashHex,
    required String claimAddress,
    required BigInt lockedAmountWei,
    required String lockerAddress,
    required int timeoutBlockHeight,
    required int chainId,
  }) {
    final now = DateTime.now();
    return SwapOutRecord(
      id: boltzId,
      boltzId: boltzId,
      status: SwapRecordStatus.created,
      createdAt: now,
      updatedAt: now,
      invoice: invoice,
      invoicePreimageHashHex: invoicePreimageHashHex,
      claimAddress: claimAddress,
      lockedAmountWeiHex: lockedAmountWei.toRadixString(16),
      lockerAddress: lockerAddress,
      timeoutBlockHeight: timeoutBlockHeight,
      chainId: chainId,
    );
  }

  /// Recover the invoice preimage hash bytes from stored hex.
  Uint8List get invoicePreimageHashBytes =>
      Uint8List.fromList(hex.decode(invoicePreimageHashHex));

  /// Recover the locked amount as BigInt from hex.
  BigInt get lockedAmountWei => BigInt.parse(lockedAmountWeiHex, radix: 16);

  /// Extract validated refund parameters. Always non-null since all required
  /// fields are guaranteed present on a [SwapOutRecord].
  SwapOutRefundParams get refundParams => SwapOutRefundParams(
        invoicePreimageHash: invoicePreimageHashBytes,
        claimAddress: claimAddress,
        lockedAmountWei: lockedAmountWei,
        timeoutBlockHeight: timeoutBlockHeight,
      );

  @override
  SwapOutRecord copyWithStatus(
    SwapRecordStatus newStatus, {
    String? resolutionTxHash,
    String? lastBoltzStatus,
    String? errorMessage,
    String? lockTxHash,
  }) {
    return SwapOutRecord(
      id: id,
      boltzId: boltzId,
      status: newStatus,
      createdAt: createdAt,
      updatedAt: DateTime.now(),
      invoice: invoice,
      invoicePreimageHashHex: invoicePreimageHashHex,
      claimAddress: claimAddress,
      lockedAmountWeiHex: lockedAmountWeiHex,
      lockerAddress: lockerAddress,
      lockTxHash: lockTxHash ?? this.lockTxHash,
      timeoutBlockHeight: timeoutBlockHeight,
      chainId: chainId,
      resolutionTxHash: resolutionTxHash ?? this.resolutionTxHash,
      lastBoltzStatus: lastBoltzStatus ?? this.lastBoltzStatus,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'boltzId': boltzId,
        'type': 'swapOut',
        'status': status.name,
        'createdAt': createdAt.toIso8601String(),
        'updatedAt': updatedAt.toIso8601String(),
        'invoice': invoice,
        'invoicePreimageHashHex': invoicePreimageHashHex,
        'claimAddress': claimAddress,
        'lockedAmountWeiHex': lockedAmountWeiHex,
        'lockerAddress': lockerAddress,
        'timeoutBlockHeight': timeoutBlockHeight,
        'chainId': chainId,
        if (lockTxHash != null) 'lockTxHash': lockTxHash,
        if (resolutionTxHash != null) 'resolutionTxHash': resolutionTxHash,
        if (lastBoltzStatus != null) 'lastBoltzStatus': lastBoltzStatus,
        if (errorMessage != null) 'errorMessage': errorMessage,
      };

  factory SwapOutRecord._fromJson(Map<String, dynamic> json) => SwapOutRecord(
        id: json['id'] as String,
        boltzId: json['boltzId'] as String,
        status: SwapRecordStatus.values.byName(json['status'] as String),
        createdAt: DateTime.parse(json['createdAt'] as String),
        updatedAt: DateTime.parse(json['updatedAt'] as String),
        invoice: json['invoice'] as String,
        invoicePreimageHashHex: json['invoicePreimageHashHex'] as String,
        claimAddress: json['claimAddress'] as String,
        lockedAmountWeiHex: json['lockedAmountWeiHex'] as String,
        lockerAddress: json['lockerAddress'] as String,
        timeoutBlockHeight: json['timeoutBlockHeight'] as int,
        chainId: json['chainId'] as int,
        lockTxHash: json['lockTxHash'] as String?,
        resolutionTxHash: json['resolutionTxHash'] as String?,
        lastBoltzStatus: json['lastBoltzStatus'] as String?,
        errorMessage: json['errorMessage'] as String?,
      );

  @override
  String toString() => 'SwapOutRecord($boltzId, $status, updated: $updatedAt)';
}

// ── Validated recovery parameter records ─────────────────────────────────

/// All fields needed to claim on-chain funds for a swap-in (reverse submarine).
class SwapInClaimParams {
  final Uint8List preimage;
  final int onchainAmountSat;
  final String refundAddress;
  final int timeoutBlockHeight;

  const SwapInClaimParams({
    required this.preimage,
    required this.onchainAmountSat,
    required this.refundAddress,
    required this.timeoutBlockHeight,
  });
}

/// All fields needed to refund locked funds for a swap-out (submarine).
class SwapOutRefundParams {
  final Uint8List invoicePreimageHash;
  final String claimAddress;
  final BigInt lockedAmountWei;
  final int timeoutBlockHeight;

  const SwapOutRefundParams({
    required this.invoicePreimageHash,
    required this.claimAddress,
    required this.lockedAmountWei,
    required this.timeoutBlockHeight,
  });
}
